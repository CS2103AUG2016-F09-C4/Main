# A0144702N
###### \java\seedu\task\commons\events\ui\JumpToEventListRequestEvent.java
``` java
    
    public JumpToEventListRequestEvent(ReadOnlyEvent event, int targetIndex) {
        this.targetIndex = targetIndex;
        this.targetEvent = event;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\seedu\task\commons\events\ui\JumpToTaskListRequestEvent.java
``` java
    public JumpToTaskListRequestEvent(ReadOnlyTask task, int targetIndex) {
        this.targetIndex = targetIndex;
        this.targetTask = task;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\seedu\task\commons\events\ui\UpdateCalendarEvent.java
``` java
public class UpdateCalendarEvent extends BaseEvent {
	private LocalDateTime displayedDateTime;
	private int calendarViewMode;
	
	public UpdateCalendarEvent(LocalDateTime displayedDateTime, int calendarViewMode) {
		this.displayedDateTime = displayedDateTime;
		this.calendarViewMode = calendarViewMode;
	}	

	@Override
	public String toString() {
		return "Setting displayed time " + this.displayedDateTime.format(StringUtil.DATE_FORMATTER) +
				" With mode: " + calendarViewMode; 
	}


	public LocalDateTime getDisplayedDateTime() {
		return displayedDateTime;
	}

	public int getCalendarViewMode() {
		return calendarViewMode;
	}


}
```
###### \java\seedu\task\commons\exceptions\CalendarUnsyncException.java
``` java
public class CalendarUnsyncException extends Exception{
	public CalendarUnsyncException(String message) {
		super(message);
	}
}
```
###### \java\seedu\task\commons\exceptions\UndoableException.java
``` java
public class UndoableException extends Exception {
	
	public UndoableException() {
		super("No more operations to undo");
	}
}
```
###### \java\seedu\task\commons\util\StringUtil.java
``` java
	/**
	 * DateTimeFormatter for LocalTimeDate fields. 
	 */
	public static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM, FormatStyle.SHORT);
	private static final int DATE_INDEX = 0;
	public static final String TIME_CONSTRAINTS = "No abbreviation is allowed for relative, ie: tmrw. \n"
			+ "But Fri, Mon, etc is okay.\n"
			+ "MM DD YY is the expected numerical sequence. \n"
			+ "Possible event duration could be:"
			+ "today 4pm /to tomorrow 4pm";
	private static final int SIMILIAR_THRESHOLD = 1; 
	/**
	 * Parse a String argument into date format. 
	 * @param parser
	 * @param dateArg
	 * @return date in LocalDateTime format
	 * @throws IllegalValueException
	 */
	public static LocalDateTime parseStringToTime(String dateArg) throws IllegalValueException {
		PrettyTimeParser parser = new PrettyTimeParser();
		
		//invalid start date
		if(dateArg == null) throw new IllegalValueException(TIME_CONSTRAINTS);
		
		List<Date> parsedResult = parser.parse(dateArg);
		
		//cannot parse
		if(parsedResult.isEmpty()) throw new IllegalValueException(TIME_CONSTRAINTS);
		
		return LocalDateTime.ofInstant(parsedResult.get(DATE_INDEX).toInstant(), ZoneId.systemDefault()); 
	}
	
	
    public static boolean containsIgnoreCase(String source, String query) {
        return source.toUpperCase().indexOf(query.toUpperCase()) != -1;
    }

    /**
     * Returns a detailed message of the t, including the stack trace.
     */
    public static String getDetails(Throwable t){
        StringWriter sw = new StringWriter();
        t.printStackTrace(new PrintWriter(sw));
        return t.getMessage() + "\n" + sw.toString();
    }

    /**
     * Returns true if s represents an unsigned integer e.g. 1, 2, 3, ... <br>
     *   Will return false for null, empty string, "-1", "0", "+1", and " 2 " (untrimmed) "3 0" (contains whitespace).
     * @param s Should be trimmed.
     */
    public static boolean isUnsignedInteger(String s){
        return s != null && s.matches("^0*[1-9]\\d*$");
    }

    
    /**
     * return true if two strings are simlar with distance less than 2. 
     * @param a
     * @param b
     * @return
     */
    public static boolean findMatch(String a, String b) {
    	
    	//short circuit if one of null
    	if(a == null || b == null) {
        	return false;
        }
        
    	//short circuit if contains
    	if(containsIgnoreCase(a, b)) {
    		return true;
    	}
    	
    	//short circuit if length differ by more than 3.
    	if(Math.abs(a.length()- b.length()) > SIMILIAR_THRESHOLD) {
    		return false;
    	}
    	
        return getDistance(a, b) <= SIMILIAR_THRESHOLD;
    }

    public static int getDistance(String a, String b) {
        
    	int aIndex = a.length()-1;
        int bIndex = b.length()-1;
        
        return levenshteinDistance(a.toUpperCase(), b.toUpperCase(), aIndex, bIndex, 0);
    }

    private static int levenshteinDistance(String a, String b, int aIndex, int bIndex, int currentCost) {
        //short circuit
    	if(aIndex < 0) return bIndex+1;
        if(bIndex < 0) return aIndex+1;
        if(currentCost > SIMILIAR_THRESHOLD) {
        	return currentCost;
        }
        
        int subCost = (a.charAt(aIndex) == b.charAt(bIndex)) ? 0 : 1;
        
        return min(
                levenshteinDistance(a, b, aIndex-1, bIndex, currentCost+1)+1,
                levenshteinDistance(a, b, aIndex, bIndex-1, currentCost+1)+1,
                levenshteinDistance(a, b, aIndex-1, bIndex-1, (currentCost+subCost))+subCost
                );
 
    }

    private static int min(int i, int j, int k) {
        int min = i;
        if(j<min) min =j;
        if(k<min) min = k;
        
        return min;
    }

}
```
###### \java\seedu\task\logic\commands\CalendarCommand.java
``` java
import seedu.taskcommons.core.LogsCenter;

/**
 * Command that updates the calendar view
 * @author xuchen
 *
 */
public class CalendarCommand extends Command {
	
	private final Logger logger = LogsCenter.getLogger(CalendarCommand.class);
	public static final String COMMAND_WORD = "show";
	public static final String MESSAGE_USAGE = COMMAND_WORD + " TIME [/day | /wk]\n" 
			+ "Shows the calendar in the specifized mode at certain time\n"
			+ "Optional flag: [/wk] to request show week view. It is the default \n"
			+ "	     [/day] to request show dayily view. "
			+ "Parameters: TIME + [OPTIONAL FLAG]\n" 
			+ "Example: "+ COMMAND_WORD + " today /day\n\n";
	
	private static final int CALENDAR_VIEW_DAY = 1;
	private static final int CALENDAR_VIEW_WEEK = 0;
	private static final String MESSAGE_SUCCESS = "Calendar showing. %1$s";
	private static final String COMMAND_LOG_FORMAT = "[Jump to: %1$s Showing: %2$s]";

	private LocalDateTime displayedDateTime;
	private boolean toWeekView;
	private boolean toDayView;
	
	
	public CalendarCommand(String displayedDateTime, boolean toggleToWeekView, boolean toggleToDayView) throws IllegalValueException {
		this.displayedDateTime = displayedDateTime.isEmpty() ? LocalDateTime.now() : StringUtil.parseStringToTime(displayedDateTime);
		this.toWeekView = toggleToWeekView;
		this.toDayView = toggleToDayView;
	}

	@Override
	public CommandResult execute() {
		logger.info("-------[Executing CalendarCommand]" + this.toString());
		if(!toWeekView && toDayView) {
			EventsCenter.getInstance().post(new UpdateCalendarEvent(displayedDateTime, CALENDAR_VIEW_DAY));
		} else {
			EventsCenter.getInstance().post(new UpdateCalendarEvent(displayedDateTime, CALENDAR_VIEW_WEEK));
		}
		
		return new CommandResult(String.format(MESSAGE_SUCCESS, this.toString()));
	}
	
	@Override
	public String toString() {
		return String.format(COMMAND_LOG_FORMAT, 
				displayedDateTime.format(StringUtil.DATE_FORMATTER),
				(toDayView) ? "Day view" : "Week view");
	}

}
```
###### \java\seedu\task\logic\commands\FindCommand.java
``` java
public class FindCommand extends Command {

    public static final String COMMAND_WORD = "find";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "\n"
    		+ "Finds all tasks and events whose names and descriptions contain any of "
            + "the similar keywords (case-sensitive) and displays them as a list with index numbers.\n"
            + "Multiple keywords need to be seperated by / followed by a space."
            + "Power search is also supported if supplied the /power flag.\n "
            + "Parameters: KEYWORD [MORE_KEYWORDS]... [/power]\n"
            + "Example: " + COMMAND_WORD + " CS2103 Project / CS2103 Assign /power";

	private static final String MESSAGE_SUCCESS_FIND = "%1$s\n%2$s";

    private final Set<String> keywords;
    private final boolean isPowerSearch;
    
    public FindCommand(Set<String> keywordSet, boolean isPowerSearch) {
		this.keywords = keywordSet;
		this.isPowerSearch = isPowerSearch;
	}
    
	@Override
    public CommandResult execute() {
		
        model.showFoundTaskList(keywords, isPowerSearch);
        model.showFoundEventList(keywords, isPowerSearch);
        
        return new CommandResult(String.format(MESSAGE_SUCCESS_FIND, 
        		getMessageForTaskListShownSummary(model.getFilteredTaskList().size()),
        		getMessageForEventListShownSummary(model.getFilteredEventList().size())));
    }

}
```
###### \java\seedu\task\logic\commands\ListCommand.java
``` java
/**
 * Abstract class to represent generic list operations.  
 * @author xuchen
 */

public abstract class ListCommand extends Command {
	public static final String COMMAND_WORD = "list";
	
	public static final String MESSAGE_USAGE = COMMAND_WORD + "\n" 
			+ COMMAND_WORD + " /t "
			+ "Shows a list of tasks that are not marked done\n"
			+ "Optional flag: [/a] to request show all tasks" 
			+ "Parameters: LIST_TYPE + [OPTIONAL FLAG]\n" 
			+ "Example: "+ COMMAND_WORD + " /t /a\n\n"
			+ COMMAND_WORD + " /e " 
			+ "Shows a list of events that are not completed yet.\n "
			+ "Optional flag: [/a] to request show all events" 
			+ "Parameters: LIST_TYPE + [OPTIONAL FLAG]\n" 
			+ "Example: "+ COMMAND_WORD + " /e /a";

	
	
	/** fields to indicate if all items should be displayed **/
	protected boolean showAll;
	
	/**
	 * Executes the command and returns the result message.
	 * @return feedback message of the operation result for display
	 */
	public abstract CommandResult execute();
	
	/**
	 * Determine if the list operations should show all items. 
	 * @return if all items should be shown
	 */
	protected boolean shouldShowAll() {
		return this.showAll;
	}
}
```
###### \java\seedu\task\logic\commands\ListEventCommand.java
``` java
/**
 * Lists all events in the task book to the user. 
 * @author xuchen
 *
 */
public class ListEventCommand extends ListCommand {
	private final Logger logger = LogsCenter.getLogger(ListEventCommand.class);
	public static final String MESSAGE_INCOMPLETED_SUCCESS = "Listed up coming events";
	public static final String MESSAGE_ALL_SUCCESS = "Listed all events";
	private static final boolean STATUS_UPCOMING = false;
	private static final String COMMAND_LOG_FORMAT = "[%1$s]";
	
	
	public ListEventCommand(boolean showAll) {
		this.showAll = showAll;
	}
	
	@Override
	/**
	 * Executes a list event operation and updates the model
	 * 
	 * @return successful command execution feedback to user
	 */
	public CommandResult execute() {
		logger.info("-------[Executing ListEventCommands]"+ this.toString() );
		if (!shouldShowAll()) {
			model.updateFilteredEventListToShowWithStatus(STATUS_UPCOMING);
			
			return new CommandResult(MESSAGE_INCOMPLETED_SUCCESS);
		} else {
			model.updateFilteredEventListToShowAll();
			return new CommandResult(MESSAGE_ALL_SUCCESS);
		}
	}
	
	@Override
	public String toString() {
		return String.format(COMMAND_LOG_FORMAT, (showAll)? "showing all" : "show only completed");
	}

}
```
###### \java\seedu\task\logic\commands\ListTaskCommand.java
``` java
/**
 * Lists all tasks in the task book to the user.
 */
public class ListTaskCommand extends ListCommand {
	private final Logger logger = LogsCenter.getLogger(ListTaskCommand.class); 
	public static final String MESSAGE_INCOMPLETED_SUCCESS = "Listed undone tasks";
	public static final String MESSAGE_ALL_SUCCESS = "Listed all tasks";
	
	private static final Boolean STATUS_INCOMPLETED = false;
	private static final String COMMAND_LOG_FORMAT = "[%1$s]";

	public ListTaskCommand(boolean showAll) {
		this.showAll = showAll;
	}
	
	@Override
	/**
	 * Executes a list task operation and updates the model
	 * 
	 * @return successful command execution feedback to user
	 */
	public CommandResult execute() {
		logger.info("-------[Executing ListTaskCommands]"+ this.toString());
		if (!shouldShowAll()) {
			model.updateFilteredTaskListToShowWithStatus(STATUS_INCOMPLETED);
			return new CommandResult(MESSAGE_INCOMPLETED_SUCCESS);
		} else {
			model.updateFilteredTaskListToShowAll();
			return new CommandResult(MESSAGE_ALL_SUCCESS);
		}
	}
	
	@Override
	public String toString() {
		return String.format(COMMAND_LOG_FORMAT, (showAll)? "showing all" : "show only completed");
	}

}
```
###### \java\seedu\task\logic\commands\UndoableCommand.java
``` java
public abstract class UndoableCommand extends Command {
    
	protected UndoableCommand reverseCommand;
	/**
     * Undo the command and returns the result message.
     * @return feedback message of the operation result for display
     */
    public abstract CommandResult undo();
}
```
###### \java\seedu\task\logic\commands\UndoCommand.java
``` java
/**
 * Undoes the most recent modification to the TaskBook
 * @author xuchen
 *
 */
public class UndoCommand extends Command{
	private final Logger logger = LogsCenter.getLogger(UndoCommand.class);
	
	
	public static final String MESSAGE_UNDO_FAILURE = "No more operations to undo";
	public static final String COMMAND_WORD = "undo";
	public static final String MESSAGE_USAGE = COMMAND_WORD +"\n" 
    		+ "Only Undo commands that modify the TaskBook in the same session will be restored.\n "
    		+ "Example: " + COMMAND_WORD;
	
    @Override
	public CommandResult execute() {
		try{
			UndoableCommand toBeUndone = commandList.pop();
			logger.info("-----------[SYSTEM UNDO COMMAND]" + toBeUndone.toString());
			return toBeUndone.undo();
		} catch (UndoableException e) {
			return new CommandResult(MESSAGE_UNDO_FAILURE);
		}

    }
}
```
###### \java\seedu\task\logic\Logic.java
``` java
    /** Convenient method returns all the events */
    List<ReadOnlyEvent> getAllEvents();
    
    /** Convenient method returns all the tasks*/
    List<ReadOnlyTask> getAllTasks();
    
}
```
###### \java\seedu\task\logic\LogicManager.java
``` java
    @Override
    public CommandResult execute(String commandText) {
        logger.info("----------------[USER COMMAND][" + commandText + "]");
        Command command = parser.parseCommand(commandText);
        if(command instanceof UndoableCommand) {
        	UndoableCommand undoableCommand = (UndoableCommand) command;
        	commandList.add(undoableCommand);
        }
        command.setData(model);
        command.setCommandHistory(commandList);
        
        return command.execute();
    }

    @Override
    public ObservableList<ReadOnlyTask> getFilteredTaskList() {
    	model.updateFilteredTaskListToShowWithStatus(false);
        return model.getFilteredTaskList();
    }

    @Override
    public ObservableList<ReadOnlyEvent> getFilteredEventList() {
    	model.updateFilteredEventListToShowWithStatus(false);
        return model.getFilteredEventList();
    }
    
    @Override
    public List<ReadOnlyEvent> getAllEvents() {
    	return model.getTaskBook().getEventList();
    }
	
    @Override
	public List<ReadOnlyTask> getAllTasks() {
		return model.getTaskBook().getTaskList();
	}
    
    
}
```
###### \java\seedu\task\logic\parser\CalendarParser.java
``` java
/**
 * Parses which parses command argument for show calendar command
 * @author xuchen
 */
public class CalendarParser implements Parser{

	@Override
	public Command prepare(String args) {
		if(args.isEmpty()) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, CalendarCommand.MESSAGE_USAGE));
		}
		
		ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(calendarViewDayPrefix, calendarViewWeekPrefix);
		
		argsTokenizer.tokenize(args.trim());
		
		try {
			Optional<String> displayedDateTime = argsTokenizer.getPreamble();
			boolean toggleToDayView = argsTokenizer.hasPrefix(calendarViewDayPrefix);
			boolean toggleToWeekView = argsTokenizer.hasPrefix(calendarViewWeekPrefix);
			
			return new CalendarCommand(displayedDateTime.orElse(""), toggleToWeekView, toggleToDayView);
		} catch (EmptyValueException e) {
			return new IncorrectCommand(e.getMessage());
		} catch (IllegalValueException ive) {
			return new IncorrectCommand(ive.getMessage());
		}
	}
}
```
###### \java\seedu\task\logic\parser\FindParser.java
``` java
/**
 * Parser to prepare FindCommand
 * @author xuchen
 *
 */
public class FindParser implements Parser {
	private static final Pattern KEYWORDS_ARGS_FORMAT =
            Pattern.compile("(?<keywords>[^/]+(?:/+[^/]+)*)"); // one or more keywords separated by '/'

    /**
     * Parses arguments in the context of the find person command.
     *
     * @param args full command args string
     * @return the prepared command
     */
	@Override
	public Command prepare(String args) {
		if(args.isEmpty()) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
				FindCommand.MESSAGE_USAGE));
		}
		
		ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(powerSearchPrefix, findKeywordPrefix);
		
		argsTokenizer.tokenize(args.trim());
		
		
		Optional<String> keyword = Optional.empty();
		Optional<List<String>> moreKeywords = Optional.empty();
		boolean isPowerSearch = false;
		
		moreKeywords = argsTokenizer.getAllValues(findKeywordPrefix);
		isPowerSearch = argsTokenizer.hasPrefix(powerSearchPrefix);
		
		try {
			keyword = argsTokenizer.getPreamble();
		} catch (EmptyValueException e) {
			//consume the exception since it is fine for find
			//do nothing.
		}
		
		final Set<String> keywordSet = combineKeywords(keyword, moreKeywords);
		return new FindCommand(keywordSet, isPowerSearch);
		
//		
//        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
//        if (!matcher.matches()) {
//            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
//                    FindCommand.MESSAGE_USAGE));
//        }
//
//        // keywords delimited by whitespace
//        final String[] keywords = matcher.group("keywords").split("/");
//        final Set<String> keywordSets = new HashSet<>(Arrays.asList(keywords));
//        return new FindCommand(keywordSet);
		
	}

	private Set<String> combineKeywords(Optional<String> keyword, Optional<List<String>> moreKeywords) {
		List<String> keywordList = moreKeywords.orElse(new ArrayList<String>());
		
		if(keyword.isPresent()) {
			keywordList.add(keyword.get());
		}
		return new HashSet<>(keywordList);
	}

}
```
###### \java\seedu\task\logic\parser\ListParser.java
``` java
/**
 * Parses list command argument
 * @author xuchen
 *
 */
public class ListParser implements Parser {

	@Override
	public Command prepare(String args) {
		//empty field is not allowed
		if (args.isEmpty()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListCommand.MESSAGE_USAGE));
        }

		ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(taskPresencePrefix, eventPresencePrefix, allPrefix);
		argsTokenizer.tokenize(args.trim());
		boolean showEvent = argsTokenizer.hasPrefix(eventPresencePrefix);
		boolean showTask = argsTokenizer.hasPrefix(taskPresencePrefix);
		boolean showAll = argsTokenizer.hasPrefix(allPrefix);
		
		//list with both flags are not supported
		if(showEvent && showTask) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListCommand.MESSAGE_USAGE));
		}
		
		if(showEvent) {
			return new ListEventCommand(showAll);
		} else if (showTask) {
			return new ListTaskCommand(showAll);
		} else {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListCommand.MESSAGE_USAGE));
		}
	}
}
```
###### \java\seedu\task\logic\UndoableCommandHistory.java
``` java
/**
 * The history for undoable commands. 
 * @author xuchen
 *
 */
public class UndoableCommandHistory {
	
	/** Stack of undoable commands **/
	private Deque<UndoableCommand> commandStack;
	
	public UndoableCommandHistory() {
		this.commandStack = new ArrayDeque<>();
	}
	
	public void add(UndoableCommand command) {
		this.commandStack.addFirst(command);
	}
	
	public UndoableCommand pop() throws UndoableException{
		try{
			return this.commandStack.removeFirst();
		} catch (NoSuchElementException e) {
			throw new UndoableException();
		}
	}
	
}
```
###### \java\seedu\task\model\item\Event.java
``` java
    /**
	 * Sort duration from earliest to latest
	 * @param o
	 * @return
	 */
	public int sortAsc(Event o) {
		return this.getDuration().compareTo(o.getDuration());
	}

	public static Comparator<? super Event> getAscComparator() {
		//first by duration
		Comparator<Event> byStartTime = (e1, e2) -> e1.getDuration().compareTo(e2.getDuration());
		
		//then by name
		Comparator<Event> byName = (e1, e2) -> e1.getEvent().compareTo(e2.getEvent());
		
		return byStartTime.thenComparing(byName);
		
	} 
	
}
```
###### \java\seedu\task\model\item\EventDuration.java
``` java
/**
 * Represents an event's duration in the task book. 
 * Guarantees: immutable; 
 * is valid as declared in {@link #isValidDuration(String)}
 */
public class EventDuration implements Comparable<EventDuration> {

	public static final String MESSAGE_DURATION_CONSTRAINTS = "Start time should be no later than end time. \n "
			+ "No abbreviation is allowed for relative, ie: tmrw. \n"
			+ "But Fri, Mon, etc is okay.\n"
			+ "Possible event duration could be:"
			+ "today 4pm /to tomorrow 4pm";
	
	private static final String MESSAGE_DURATION_FORMAT = "From: %1$s to %2$s";
	private static final long DEFAULT_DURATION = 1;
	
	
	private LocalDateTime startTime;
	private LocalDateTime endTime;
	

	/**
	 * Creates a given duration.
	 *
	 * @throws IllegalValueException
	 *   		if given duration string is invalid.
	 */
	public EventDuration(String startTimeArg, String endTimeArg) throws IllegalValueException {
		assert startTimeArg != null;
		assert endTimeArg != null;
		try {
			parseDuration(startTimeArg, endTimeArg);
		} catch (IllegalValueException ive) {
			throw new IllegalValueException(MESSAGE_DURATION_CONSTRAINTS);
		}
	}

	
	private void parseDuration(String startTimeArg, String endTimeArg) throws IllegalValueException {
		//if start time empty, set end time first, and start time will be {@code DEFAULT_DURATION} before.  
		if(startTimeArg.isEmpty()) {
			setEndTime(StringUtil.parseStringToTime(endTimeArg));
			setStartTime(getEndTime().minusHours(DEFAULT_DURATION));
			return;
		} 
		
		// if end time empty, set start time first, and end time will be {@code DEFAULT_DURATION} later. 
		if(endTimeArg.isEmpty()) {
			setStartTime(StringUtil.parseStringToTime(startTimeArg));
			setEndTime(getStartTime().plusHours(DEFAULT_DURATION));
			return;
		}
		
		setStartTime(StringUtil.parseStringToTime(startTimeArg));
		setEndTime(StringUtil.parseStringToTime(endTimeArg));
		
		if(!isValidDuration()) {
			throw new IllegalValueException(MESSAGE_DURATION_CONSTRAINTS);
		}
	}

	/**
	 * start time must be before end time.
	 * @return if duration valid
	 */
	private boolean isValidDuration() {
		return getStartTime().isBefore(getEndTime());
	}


	public LocalDateTime getStartTime() {
		return startTime;
	}

	private void setStartTime(LocalDateTime startTime) {
		this.startTime = startTime;
	}

	public LocalDateTime getEndTime() {
		return endTime;
	}

	private void setEndTime(LocalDateTime endTime) {
		this.endTime = endTime;
	}

	@Override
	public String toString() {
		return String.format(MESSAGE_DURATION_FORMAT, 
				getStartTime().format(StringUtil.DATE_FORMATTER), 
				getEndTime().format(StringUtil.DATE_FORMATTER));
	}
	
	/**
	 * format start time for UI 
	 * @return
	 */
	public String getStartTimeAsText() {
		return getStartTime().format(StringUtil.DATE_FORMATTER);
	}
	
	/**
	 * format end time for UI.
	 * @return
	 */
	public String getEndTimeAsText() {
		return getEndTime().format(StringUtil.DATE_FORMATTER);
	}
```
###### \java\seedu\task\model\item\Task.java
``` java
	/**
	 * Sort deadline from earliest to latest
	 * @param o
	 * @return
	 */
	public static Comparator<Task> getAscComparator() {
		//first by deadline
		Comparator<Task> byDeadline = (t1, t2) -> {
			if(!t1.getDeadline().isPresent() && !t2.getDeadline().isPresent())
				return 0;
			// if this is a floating task, it will be on the top
			if(!t1.getDeadline().isPresent())
				return -1;
			if(!t2.getDeadline().isPresent()) 
				return 1;
			
			//if both are not floating tasks 
			return t1.getDeadline().get().compareTo(t2.getDeadline().get());
		};
		
		//then by name
		Comparator<Task> byName = (t1, t2) -> t1.getTask().compareTo(t2.getTask());
		
		return byDeadline.thenComparing(byName);
	}
	
	/**
	 * Sort deadline from latest to earliest
	 * @param o
	 * @return
	 */
	public int sortDesc(Task o) {
		if(!this.getDeadline().isPresent() && !o.getDeadline().isPresent())
			return 0;
		// if this is a floating task, it will be on the top
		if(!this.getDeadline().isPresent())
			return -1;
		// if this is 
		if(!o.getDeadline().isPresent()) 
			return 1;
		return this.getDeadline().get().compareTo(o.getDeadline().get())*(-1);
		
	}

}
```
###### \java\seedu\task\model\ModelManager.java
``` java
    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList() {
    	SortedList<Task> sortedTasks = new SortedList<>(filteredTasks);
    	sortedTasks.setComparator(Task.getAscComparator());
    	return new UnmodifiableObservableList<>(sortedTasks);
    }
   
    
    @Override
    public UnmodifiableObservableList<ReadOnlyEvent> getFilteredEventList() {
        SortedList<Event> sortedEvents = new SortedList<>(filteredEvents);
    	sortedEvents.setComparator(Event.getAscComparator());
    	return new UnmodifiableObservableList<>(sortedEvents);
    }

    @Override
    public void updateFilteredTaskListToShowAll() {
        filteredTasks.setPredicate(null);
    }

    @Override
    public void showFoundTaskList(Set<String> keywords, boolean isPowerSearch){
        updateFilteredTaskList(new PredicateExpression(new NameQualifier(keywords, isPowerSearch)));
    }
    
    @Override
    public void showFoundEventList(Set<String> keywords, boolean isPowerSearch){
        updateFilteredEventList(new PredicateExpression(new NameQualifier(keywords, isPowerSearch)));
    }
    
    @Override
	public void updateFilteredTaskListToShowWithStatus(Boolean status) {
		updateFilteredTaskList(new PredicateExpression(new StatusQualifier(status)));
		
	}
    
    @Override
	public void updateFilteredEventListToShowWithStatus(Boolean status) {
    	updateFilteredEventList(new PredicateExpression(new StatusQualifier(status)));
	}
    
    @Override
	public void updateFilteredEventListToShowAll() {
    	filteredEvents.setPredicate(null);
	}
    
```
###### \java\seedu\task\model\ModelManager.java
``` java
    interface Qualifier {
        boolean run(ReadOnlyTask task);
        boolean run(ReadOnlyEvent event);
        String toString();
    }

    private class NameQualifier implements Qualifier {
    	private boolean isPowerSearch;
    	private Set<String> keyWords;
    	
        private String taskName;
        private String taskDesc; 
        private String eventName;
        private String eventDesc; 
        NameQualifier(Set<String> keyWords, boolean isPowerSearch) {
            this.keyWords = keyWords;
            this.isPowerSearch = isPowerSearch;
        }

		@Override
        public boolean run(ReadOnlyTask task) {
        	taskName = task.getTask().fullName;
    		taskDesc = task.getDescriptionValue();
    		List<String> sourceSet = new ArrayList<>();
    		
        	if(isPowerSearch) {
        		//break the name and desc to allow power search
        		sourceSet = new ArrayList<>(Arrays.asList(taskName.split("\\s")));
        		sourceSet.addAll(Arrays.asList(taskDesc.split("\\s")));
        		
        		//break the keyword to allow power search
        		List<String> tempSet = new ArrayList<>(keyWords);
        		keyWords = new HashSet<>();
        		tempSet.stream().forEach(keyword -> keyWords.addAll(Arrays.asList(keyword.split("\\s"))));
        		
        	} else {
        		sourceSet.add(taskName);
        		sourceSet.add(taskDesc);
        	}
        	
        	for(String source: sourceSet) {
    			boolean found = keyWords.stream()
                .filter(keyword -> StringUtil.findMatch(source.trim(), keyword.trim()))
                .findAny()
                .isPresent();
    			
    			if (found) {
    				return true;
    			}
    		}
    		return false;
        }

        @Override
        public String toString() {
            return "task=" + String.join(", ", keyWords);
        }

		@Override
		public boolean run(ReadOnlyEvent event) {
			eventName = event.getEvent().fullName;
    		eventDesc = event.getDescriptionValue();
    		List<String> sourceSet = new ArrayList<>();
    		
        	if(isPowerSearch) {
        		//break the name and desc to allow power search
        		sourceSet = new ArrayList<>(Arrays.asList(eventName.split("\\s")));
        		sourceSet.addAll(Arrays.asList(eventDesc.split("\\s")));
        		
        		//break the keyword to allow power search
        		List<String> tempSet = new ArrayList<>(keyWords);
        		keyWords = new HashSet<>();
        		tempSet.stream().forEach(keyword -> keyWords.addAll(Arrays.asList(keyword.split("\\s"))));
        		
        	} else {
        		sourceSet.add(eventName);
        		sourceSet.add(eventDesc);
        	}
        	
        	for(String source: sourceSet) {
    			boolean found = keyWords.stream()
                .filter(keyword -> StringUtil.findMatch(source.trim(), keyword.trim()))
                .findAny()
                .isPresent();
    			
    			if (found) {
    				return true;
    			}
    		}
    		return false;
		}
    }
    
    private class StatusQualifier implements Qualifier {
    	private Boolean status;
    	
    	StatusQualifier(boolean status){
    		this.status = status;
    	}
    	
		@Override
		public boolean run(ReadOnlyTask task) {
			return task.getTaskStatus().equals(status);
		}
		
		@Override 
		public String toString() {
			return (status ? "completed" : "not yet completed");  
		}

		@Override
		public boolean run(ReadOnlyEvent event) {
			return event.isEventCompleted() == status;
		}
    	
    }

}
```
###### \java\seedu\task\ui\CalendarHelper.java
``` java
public class CalendarHelper extends AppointmentImplBase implements Appointment {
	private static final String EVENT_GROUP = "group11";
	private static final long DEFAULT_DURATION = 1;
	private static final String TASK_GROUP = "group10";
	private static Map<String, AppointmentGroup> groupMap;
	private static CalendarHelper instance;
	
	
	private CalendarHelper() {
		setGroups();
	}
	
	private static void setGroups() {
		groupMap = new HashMap<>();
		for (AppointmentGroup group : new Agenda().appointmentGroups()) {
			groupMap.put(group.getDescription(), group);
		}
	}
	
	public Appointment convertFromEvent(ReadOnlyEvent event) {
		Appointment item = new AppointmentImplLocal();
		item.setSummary(event.getEvent().fullName);
		item.setStartLocalDateTime(event.getDuration().getStartTime());
		item.setEndLocalDateTime(event.getDuration().getEndTime());
		item.setDescription(event.getDescriptionValue());
		item.setAppointmentGroup(groupMap.get(EVENT_GROUP));
		
		return item;
	}
	

	public Appointment convertFromTask(ReadOnlyTask task) {
		Appointment item = new AppointmentImplLocal();
		item.setSummary(task.getTask().fullName);
		item.setStartLocalDateTime(task.getDeadline().get().getTime());
		item.setEndLocalDateTime(item.getStartLocalDateTime().plusHours(DEFAULT_DURATION));
		item.setDescription(task.getDescriptionValue());
		item.setAppointmentGroup(groupMap.get(TASK_GROUP));
		return item;
	}

	public static CalendarHelper getInstance() {
		if (instance == null) {
			instance = new CalendarHelper();
		}
		return instance;
	}

	public static boolean compareWithTask(ReadOnlyTask targetTask, Appointment taskInCalendar) {
		assert targetTask.getDeadline().isPresent();
		return taskInCalendar.getSummary().equals(targetTask.getTask().fullName)
				&& taskInCalendar.getStartLocalDateTime().equals(targetTask.getDeadline().get().getTime());
	}

	public static boolean compareWithEvent(ReadOnlyEvent targetEvent, Appointment eventInCalendar) {
		return eventInCalendar.getSummary().equals(targetEvent.getEvent().fullName)
				&& eventInCalendar.getStartLocalDateTime().equals(targetEvent.getDuration().getStartTime())
				&& eventInCalendar.getEndLocalDateTime().equals(targetEvent.getDuration().getEndTime());
	}
	
	public boolean isTask(Appointment appointment) {
		AppointmentGroup group =  appointment.getAppointmentGroup();
		return group.getStyleClass().equals(TASK_GROUP);
		
	}

	public boolean isEvent(Appointment appointment) {
		return !isTask(appointment);
	}
}
```
###### \java\seedu\task\ui\CalendarPanel.java
``` java

/**
 * The Calendar window controller
 * 		Responsible for loading the calendar
 * 		Updating the calendar view 
 * @author xuchen
 *
 */
public class CalendarPanel extends UiPart {
	private static final int DAY_SKIN = 1;
	private static final int WEEK_SKIN = 0;
	private static final String CALENDAR_UNSYC_MESSAGE = "Calendar is unsync";
	private static final String CALENDAR_VIEW_ID = "calendar";
	private static final int DEFAULT_BEFORE = -1;
	private static final int DEFAULT_AFTER = 5;
	private Agenda agenda;
	private final Logger logger = LogsCenter.getLogger(CalendarPanel.class);
	private AnchorPane placeHolderPane;
	private final CalendarHelper calHelper;
	
	

	public CalendarPanel() {
		agenda = new Agenda();
		calHelper = CalendarHelper.getInstance();
	}

	public static CalendarPanel load(Stage primaryStage, AnchorPane calendarPlaceHolder,
			List<ReadOnlyEvent> eventList, List<ReadOnlyTask> taskList) {
		CalendarPanel calendarPanel = new CalendarPanel();
		calendarPanel.setupCalendar(primaryStage, calendarPlaceHolder);
		calendarPanel.configure(eventList, taskList);
		return calendarPanel;
	}

	private void setupCalendar(Stage primaryStage, AnchorPane calendarPlaceHolder) {
		logger.info("Setting up Calendar panel...");
		
		setStage(primaryStage);
		setPlaceholder(calendarPlaceHolder);
		setBoundary();
		setWeekView(DEFAULT_BEFORE, DEFAULT_AFTER);
		this.agenda.setAllowDragging(false);
		this.agenda.setDisplayedLocalDateTime(LocalDateTime.now());
		resetCallBack();
		addToPlaceHodler();
	}
	
	private void setWeekView(int before, int after) {
		AgendaDaysFromDisplayedSkin skin = new AgendaDaysFromDisplayedSkin(this.agenda);
		skin.setDaysBeforeFurthest(before);
		skin.setDaysAfterFurthest(after);
		Slider slider = (Slider)this.agenda.lookup("#daysAfterSlider");
		slider.setValue(3.0);
		this.agenda.setSkin(skin);
	}

	/**
	 * Reset callbacks which modify the calendar so that the calendar depends solely on the event list
	 */
	private void resetCallBack() {
		agenda.setActionCallback( new Callback<Appointment, Void>() {
			@Override
			public Void call(Appointment param) {
				logger.info(param.getSummary() + " is selected. ");
				return null;
			}
		});
		
		agenda.setEditAppointmentCallback( new Callback<Appointment, Void>() {
			@Override
			public Void call(Appointment param) {
				// Do nothing
				return null;
			}
		});
		
		agenda.setNewAppointmentCallback( new Callback<LocalDateTimeRange, Appointment>() {
			@Override
			public Appointment call(LocalDateTimeRange param) {
				// Not allowing adding new events by clicking.
				return null;
			}
		});
		
	}

	private void addToPlaceHodler() {
		SplitPane.setResizableWithParent(placeHolderPane, true);
		agenda.setId(CALENDAR_VIEW_ID);
		placeHolderPane.getChildren().add(agenda);
	}

	private void configure(List<ReadOnlyEvent> eventList, List<ReadOnlyTask> taskList) {
		setConnection(eventList, taskList);
	}
	
	private void setConnection(List<ReadOnlyEvent> eventList, List<ReadOnlyTask> taskList) {
		agenda.appointments().clear();
		agenda.selectedAppointments().clear();
		setConnectionEvent(eventList);
		setConnectionTask(taskList);
	}

	private void setConnectionEvent(List<ReadOnlyEvent> eventList) {
		eventList.forEach(event ->
			agenda.appointments().add(calHelper.convertFromEvent(event)));
	}
	
	private void setConnectionTask(List<ReadOnlyTask> taskList) {
		taskList.stream()
			.filter(task -> task.getDeadline().isPresent() && !task.getTaskStatus().booleanValue())
			.collect(Collectors.toList())
			.forEach(task -> agenda.appointments().add(calHelper.convertFromTask(task)));
	}

	
	/**
	 * Focus the calendar to a certain time frame
	 * @param t
	 */
	public void updateCalendarShownPeriod(LocalDateTime t) {
		agenda.setDisplayedLocalDateTime(t);
	}
	

	private void setBoundary() {
		AnchorPane.setTopAnchor(agenda, 0.0);
		AnchorPane.setBottomAnchor(agenda, 0.0);
		AnchorPane.setLeftAnchor(agenda, 0.0);
		AnchorPane.setRightAnchor(agenda, 0.0);
	}

	@Override
	public void setPlaceholder(AnchorPane placeholder) {
		this.placeHolderPane = placeholder;
	}

	@Override
	public void setNode(Node node) {

	}

	/**
	 * Not use Fxml
	 * @return
	 */
	@Override
	public String getFxmlPath() {
		return "";

	}

	/** 
	 * Refresh data shown when eventlist in model modified
	 * @param eventList
	 */
	public void refresh(List<ReadOnlyEvent> eventList, List<ReadOnlyTask> taskList) {
		logger.info("Refreshing calendar...");
		setConnection(eventList, taskList);
	}

	/**
	 * Toggle the Calendar display mode
	 * @param calendarViewMode
	 */
	public void updateCalendarMode(int calendarViewMode) {
		switch(calendarViewMode) {
		case DAY_SKIN:
			agenda.setSkin(new AgendaDaySkin(agenda));
			break;
		case WEEK_SKIN:
			setWeekView(DEFAULT_BEFORE, DEFAULT_AFTER);
			break;
		default:
			setWeekView(DEFAULT_BEFORE, DEFAULT_AFTER);
		}
	}
	
	/**
	 * Select a event in the calendar and show its details. 
	 * @param targetEvent
	 * @throws exception if calendar is not sync with event list. Restart needed.
	 */
	public void select(ReadOnlyEvent targetEvent) throws CalendarUnsyncException {
		// focus on the event
		LocalDateTime displayedDateTime = targetEvent.getDuration().getStartTime();
		updateCalendarShownPeriod(displayedDateTime);
		
		//highlight the event 
		Appointment targetAppoint  = agenda.appointments()
				.stream()
				.filter((Predicate<? super Agenda.Appointment>) eventInCalendar 
						-> CalendarHelper.compareWithEvent(targetEvent, eventInCalendar))
				.findAny()
				.orElseThrow(()-> new CalendarUnsyncException(CALENDAR_UNSYC_MESSAGE));
		
		agenda.selectedAppointments().add(targetAppoint);
	}

	public void select(ReadOnlyTask targetTask) throws CalendarUnsyncException {
		if(isCompleted(targetTask) || isFloating(targetTask)) {
			return;
		}
		LocalDateTime displayedDateTime = targetTask.getDeadline().get().getTime();
		updateCalendarShownPeriod(displayedDateTime);
		
		Appointment targetAppoint = agenda.appointments().stream()
				.filter((Predicate<? super Agenda.Appointment>) taskInCalendar 
						-> CalendarHelper.compareWithTask(targetTask, taskInCalendar))
				.findAny()
				.orElseThrow(() -> new CalendarUnsyncException(CALENDAR_UNSYC_MESSAGE));
		
		agenda.selectedAppointments().add(targetAppoint);
	}

	private boolean isFloating(ReadOnlyTask targetTask) {
		return !targetTask.getDeadline().isPresent();
	}

	private boolean isCompleted(ReadOnlyTask targetTask) {
		return targetTask.getTaskStatus();
	}
}
```
###### \java\seedu\task\ui\UiManager.java
``` java
	@Subscribe
	private void handleJumpToEListRequestEvent(JumpToEventListRequestEvent event) throws CalendarUnsyncException {
		logger.info(LogsCenter.getEventHandlingLogMessage(event));
		mainWindow.getEventListPanel().scrollTo(event.targetIndex);
		mainWindow.getCalendarPanel().select(event.targetEvent);
	}
	
	@Subscribe
	private void handleEventListUpdatedEvent(TaskBookChangedEvent event) {
		logger.info(LogsCenter.getEventHandlingLogMessage(event));
		mainWindow.updateCalendar(event.data.getEventList(), event.data.getTaskList());
	}
	
	@Subscribe 
	private void handleCalendarViewUpdatedEvent(UpdateCalendarEvent event){
		logger.info(LogsCenter.getEventHandlingLogMessage(event));
		mainWindow.updateCalendarView(event.getDisplayedDateTime(), event.getCalendarViewMode());
	}
}
```
###### \resources\view\DarkTheme.css
``` css
@font-face {
	src: url("/roboto/RobotoCondensed-Light.ttf");
}
@font-face {
	src: url("./roboto/Roboto-Bold.ttf");
}
@font-face {
	src: url("./roboto/Roboto-Medium.ttf");
}

.root {
	-fx-font-family: 'Roboto Condensed Light', Arial, sans-serif;
	-fx-focus-color: SaddleBrown;
	-fx-faint-focus-color: SaddleBrown;
}

.cell_big_label {
    -fx-font-size: 16px;
    -fx-text-fill: #010504;
}

.cell_desc_label {
    -fx-font-size: 11px !important;
    -fx-text-fill: #bdc3c7;
    
}

.cell_ddl_label {
    -fx-font-size: 11px !important;
    -fx-text-fill: #c0392b;
    -fx-background-image: url('/images/calendar.png');
    -fx-background-position: left center;
  	-fx-background-repeat: no-repeat;
  	 -fx-background-size: 15px;
}

.cell_small_label {
    -fx-font-size: 9px;
    -fx-text-fill: #010504;
}

.background {
    -fx-background-color: derive(#1d1d1d, 20%);
}

.label {
    -fx-font-size: 11pt;
   	-fx-font-family: "Roboto Medium", Arial, sans-serif;
    -fx-opacity: 0.9;
}

.label-bright {
    -fx-font-size: 11pt;
    -fx-text-fill: white;
    -fx-opacity: 1;
}

.label-header {
    -fx-font-size: 20pt;
    -fx-font-family: "Roboto Condensed Light", Arial, sans-serif;
    -fx-text-fill: white;
    -fx-opacity: 1;
}

.text-field {
    -fx-font-size: 12pt;
    -fx-font-family: "Roboto Condensed Light", Arial, sans-serif;
}

```
###### \resources\view\Extensions.css
``` css

/**Group 1 for events */
.group11{
	-fx-background-color: #ecf0f1;
	-fx-fill:transparent; 
	-fx-border-width: 4px;
	-fx-text-fill: white;
	-fx-border-width: 5px 0px 5px 0px;
	-fx-border-color: #1abc9c ;
}

/**Group  10 for tasks undone */
.group10 { 
	-fx-background-image: url('/images/clipboard.png');
    -fx-background-position: right center;
    -fx-background-image-width: 5px;
    -fx-background-image-height: 5px;
  	-fx-background-repeat: no-repeat; 
	-fx-background-color: transparent;
	-fx-fill: #AC725E; 
	-fx-border-width: 5px 0px 5px 0px;
	-fx-border-color: #c0392b;
	-fx-text-fill: #7f8c8d;
}

.anchor-pane{
	-fx-background-color: #7f8c8d;
}

.event-panel-header {
	-fx-font-family: 'Roboto Bold', Arial, sans-serif;
	-fx-font-size:20px;
	-fx-text-fill: #ecf0f1;
	-fx-background-color:#c0392b;
}

.task-panel-header {
	-fx-font-size:20px;
	-fx-text-fill: #ecf0f1;
	-fx-background-color:#1abc9c;
	-fx-font-family: 'Roboto Bold', Arial, sans-serif;
}


.Agenda .Selected { 
	-xfx-color: -fx-focused-base;
	-fx-background-color: #f1c40f, -fx-outer-border, -fx-inner-border, #f1c40f;
	-fx-background-insets: -1.4, 0, 1, 2;
	-fx-background-radius: 10, 5, 4, 3;
}

.error {
    -fx-background-color: red;
}

.status-complete {
    -fx-background-color: #2ecc71;
    -fx-background-image: url('/images/checked.png');
    -fx-background-position: right center;
  	-fx-background-repeat: no-repeat;
  	-fx-background-size: 25px;
  	-fx-right-padding: 10px;
}


.tag-selector {
    -fx-border-width: 1;
    -fx-border-color: white;
    -fx-border-radius: 3;
    -fx-background-radius: 3;
}

.tooltip-text {
    -fx-text-fill: white;
}



```
