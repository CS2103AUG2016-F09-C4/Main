# A0144702N
###### /java/seedu/task/commons/core/CalendarView.java
``` java
/**
 * Describes the calendar view
 * @author xuchen
 *
 */
public enum CalendarView {
	DAY, WEEK
}
```
###### /java/seedu/task/commons/core/Status.java
``` java
/**
 * Status of events/tasks should be shown in the list. 
 * @author xuchen
 *
 */
public enum Status {
	ALL, COMPLETED, INCOMPLETED;
	
}
```
###### /java/seedu/task/commons/events/ui/JumpToEventListRequestEvent.java
``` java
/**
 * Indicates a request to jump to the list of items
 */
public class JumpToEventListRequestEvent extends BaseEvent {

    public final int targetIndex;
    public final ReadOnlyEvent targetEvent;

    public JumpToEventListRequestEvent(ReadOnlyEvent event, int targetIndex) {
        this.targetIndex = targetIndex;
        this.targetEvent = event;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### /java/seedu/task/commons/events/ui/JumpToTaskListRequestEvent.java
``` java
/**
 * Indicates a request to jump to the list of items
 */
public class JumpToTaskListRequestEvent extends BaseEvent {

    public final int targetIndex;
    public final ReadOnlyTask targetTask;

    public JumpToTaskListRequestEvent(ReadOnlyTask task, int targetIndex) {
        this.targetIndex = targetIndex;
        this.targetTask = task;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### /java/seedu/task/commons/events/ui/UpdateCalendarEvent.java
``` java
public class UpdateCalendarEvent extends BaseEvent {
	private LocalDateTime displayedDateTime;
	private CalendarView calendarViewMode;
	
	public UpdateCalendarEvent(LocalDateTime displayedDateTime, CalendarView calendarViewMode) {
		this.displayedDateTime = displayedDateTime;
		this.calendarViewMode = calendarViewMode;
	}	

	@Override
	public String toString() {
		return "Setting displayed time " + this.displayedDateTime.format(StringUtil.DATE_FORMATTER)
		+" With mode: " + calendarViewMode; 
	}

	public LocalDateTime getDisplayedDateTime() {
		return displayedDateTime;
	}

	public CalendarView getCalendarViewMode() {
		return calendarViewMode;
	}
}
```
###### /java/seedu/task/commons/exceptions/CalendarUnsyncException.java
``` java
@SuppressWarnings("serial")
public class CalendarUnsyncException extends Exception{
	public CalendarUnsyncException(String message) {
		super(message);
	}
}
```
###### /java/seedu/task/commons/exceptions/UndoableException.java
``` java
@SuppressWarnings("serial")
public class UndoableException extends Exception {
	
	public UndoableException() {
		super("No more operations to undo");
	}
}
```
###### /java/seedu/task/commons/util/StringUtil.java
``` java
/**
 * Helper functions for handling strings.
 */
public class StringUtil {
	/**
	 * DateTimeFormatter for LocalTimeDate fields. 
	 */
	public static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM, FormatStyle.SHORT);
	private static final int DATE_INDEX = 0;
	public static final String TIME_CONSTRAINTS = "No abbreviation is allowed for relative, ie: tmrw. \n"
			+ "But Fri, Mon, etc is okay.\n"
			+ "MM DD YY is the expected numerical sequence. \n"
			+ "Possible event duration could be:"
			+ "today 4pm /to tomorrow 4pm";

	/**
	 * Parse a String argument into date format. 
	 * @param parser
	 * @param dateArg
	 * @return date in LocalDateTime format
	 * @throws IllegalValueException
	 */
	public static LocalDateTime parseStringToTime(String dateArg) throws IllegalValueException {
		//empty start date
		if(dateArg == null) throw new IllegalValueException(TIME_CONSTRAINTS);
		
		PrettyTimeParser parser = new PrettyTimeParser();
		List<Date> parsedResult = parser.parse(dateArg);
		
		//cannot parse
		if(parsedResult.isEmpty()) throw new IllegalValueException(TIME_CONSTRAINTS);
		
		//wrap in LocalDateime class
		return LocalDateTime.ofInstant(parsedResult.get(DATE_INDEX).toInstant(), ZoneId.systemDefault()); 
	}
	
	
    public static boolean containsIgnoreCase(String source, String query) {
        return source.toUpperCase().indexOf(query.toUpperCase()) != -1;
    }

	private static final int SIMILIAR_THRESHOLD = 1; 
    /**
     * Check if two strings are similar 
     * @param a
     * @param b
     * @return
     */
    public static boolean isSimilar(String a, String b) {
    	
    	//short circuit if one of null
    	if(a == null || b == null) {
        	return false;
        }
        
    	//short circuit if contains
    	if(containsIgnoreCase(a, b)) {
    		return true;
    	}
    	
    	//short circuit if length differ by more than 3.
    	if(Math.abs(a.length()- b.length()) > SIMILIAR_THRESHOLD) {
    		return false;
    	}
    	
        return getDistance(a, b) <= SIMILIAR_THRESHOLD;
    }

    /**
     * Calcuates Levenshteisn Distance of two strings
     * @param a
     * @param b
     * @return
     */
    public static int getDistance(String a, String b) {
    	int aIndex = a.length()-1;
        int bIndex = b.length()-1;
        
        return levenshteinDistance(a.toUpperCase(), b.toUpperCase(), aIndex, bIndex, 0);
    }

    private static int levenshteinDistance(String a, String b, int aIndex, int bIndex, int currentCost) {
        //short circuit
    	if(aIndex < 0) return bIndex+1;
        if(bIndex < 0) return aIndex+1;
        if(currentCost > SIMILIAR_THRESHOLD) {
        	return currentCost;
        }
        
        int subCost = (a.charAt(aIndex) == b.charAt(bIndex)) ? 0 : 1;
        return min(
                levenshteinDistance(a, b, aIndex-1, bIndex, currentCost+1)+1,
                levenshteinDistance(a, b, aIndex, bIndex-1, currentCost+1)+1,
                levenshteinDistance(a, b, aIndex-1, bIndex-1, (currentCost+subCost))+subCost
                );
 
    }
    
    private static int min(int i, int j, int k) {
        int min = i;
        if(j<min) min =j;
        if(k<min) min = k;
        
        return min;
    }
```
###### /java/seedu/task/logic/commands/CalendarCommand.java
``` java
/**
 * Command that updates the calendar view
 * @author xuchen
 *
 */
public class CalendarCommand extends Command {
	private final Logger logger = LogsCenter.getLogger(CalendarCommand.class);
	
	public static final String COMMAND_WORD = "show";
	public static final String MESSAGE_USAGE = COMMAND_WORD + "\n"
			+ "TIME [/day | /wk]\n" 
			+ "Shows the calendar in the specifized mode at certain time\n"
			+ "Optional flag: [/wk] to request show week view. It is the default \n"
			+ "[/day] to request show dayily view.\n"
			+ "Parameters: TIME + [OPTIONAL FLAG]\n" 
			+ "Example: "+ COMMAND_WORD + " today /day\n\n";
	
	private static final String MESSAGE_SUCCESS = "Calendar showing. %1$s";
	private static final String COMMAND_LOG_FORMAT = "[Jump to: %1$s Showing: %2$s]";

	private LocalDateTime displayedDateTime;
	private CalendarView view;
	
	
	public CalendarCommand(String displayedDateTime, CalendarView view) throws IllegalValueException {
		this.displayedDateTime = displayedDateTime.isEmpty() ? LocalDateTime.now() : StringUtil.parseStringToTime(displayedDateTime);
		this.view = view;
	}

	@Override
	public CommandResult execute() {
		logger.info("-------[Executing CalendarCommand]" + this.toString());
		
		EventsCenter.getInstance().post(new UpdateCalendarEvent(displayedDateTime, view));
		return new CommandResult(String.format(MESSAGE_SUCCESS, this.toString()));
	}
	
	@Override
	public String toString() {
		return String.format(COMMAND_LOG_FORMAT, 
				displayedDateTime.format(StringUtil.DATE_FORMATTER),
				view);
	}

}
```
###### /java/seedu/task/logic/commands/FindCommand.java
``` java
/**
 * Finds and lists all persons in address book whose name contains any of the argument keywords.
 * Keyword matching is case sensitive.
 * @author xuchen
 */
public class FindCommand extends Command {

    public static final String COMMAND_WORD = "find";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "\n"
    		+ "Finds all tasks and events whose names and descriptions contain any of "
            + "the similar keywords (case-sensitive) and displays them as a list with index numbers.\n"
            + "Multiple keywords need to be seperated by / followed by a space."
            + "Power search is also supported if supplied the /power flag.\n "
            + "Parameters: KEYWORD [MORE_KEYWORDS]... [/power]\n"
            + "Example: " + COMMAND_WORD + " CS2103 Project / CS2103 Assign /power";

	private static final String MESSAGE_SUCCESS_FIND = "%1$s\n%2$s";

    private final Set<String> keywords;
    private final boolean isPowerSearch;
    
    public FindCommand(Set<String> keywordSet, boolean isPowerSearch) {
		this.keywords = keywordSet;
		this.isPowerSearch = isPowerSearch;
	}
    
	@Override
    public CommandResult execute() {
        model.showFoundTaskList(keywords, isPowerSearch);
        model.showFoundEventList(keywords, isPowerSearch);
        
        return new CommandResult(String.format(MESSAGE_SUCCESS_FIND, 
        		getMessageForTaskListShownSummary(model.getFilteredTaskList().size()),
        		getMessageForEventListShownSummary(model.getFilteredEventList().size())));
    }

}
```
###### /java/seedu/task/logic/commands/ListCommand.java
``` java
/**
 * Represent  list operations.  
 * @author xuchen
 */

public class ListCommand extends Command {
	private final Logger logger = LogsCenter.getLogger(ListCommand.class);
	public static final String COMMAND_WORD = "list";
	public static final String MESSAGE_USAGE = COMMAND_WORD + "\n" 
			+ COMMAND_WORD + " /t "
			+ "Shows a list of tasks that are not marked done\n"
			+ "Optional flag: [/a] to request show all tasks" 
			+ "Parameters: LIST_TYPE + [OPTIONAL FLAG]\n" 
			+ "Example: "+ COMMAND_WORD + " /t /a\n\n"
			+ COMMAND_WORD + " /e " 
			+ "Shows a list of events that are not completed yet.\n "
			+ "Optional flag: [/a] to request show all events" 
			+ "Parameters: LIST_TYPE + [OPTIONAL FLAG]\n" 
			+ "Example: "+ COMMAND_WORD + " /e /a"
			+ COMMAND_WORD + " [/e /t]"
			+ "Shows both lists of upcoming tasks and events"				+ "Optional flag: [/a] to request shows all completed ones "
			+ "Parameters:[OPTIONAL FLAG]\n" 
			+ "Example: "+ COMMAND_WORD + "/a";
	public static final String MESSAGE_SUCCESS_FORMAT = "Dowat is showing %1$s %2$s";
	
	/** which panel to list **/
	private ListTarget listTarget;
	/** fields to indicate items of which state should be displayed **/
	private Status status;
	
	public ListCommand(ListTarget targetPanel, Status filter) {
		this.listTarget = targetPanel;
		this.status = filter;
	}
	
	/**
	 * Executes the command and returns the result message.
	 * @return feedback message of the operation result for display
	 */
	public CommandResult execute() {
		logger.info("-------[Executing ListCommands]"+ this.toString() );
		
		switch (listTarget) {
		case EVENT:
			model.updateFilteredEventListToShowWithStatus(status);
			break;
		case TASK:
			model.updateFilteredTaskListToShowWithStatus(status);
			break;
		case BOTH:
			model.updateFilteredTaskListToShowWithStatus(status);
			model.updateFilteredEventListToShowWithStatus(status);
			break;
		default:
			return new CommandResult(MESSAGE_USAGE);
		}
		
		return new CommandResult(this.toString());
	}
	
	@Override
	public String toString() {
		return String.format(MESSAGE_SUCCESS_FORMAT,
						this.status, 
						listTarget.toString());
	}
}
```
###### /java/seedu/task/logic/commands/UndoableCommand.java
``` java
public abstract class UndoableCommand extends Command {
    
	protected UndoableCommand reverseCommand;
	/**
     * Undo the command and returns the result message.
     * @return feedback message of the operation result for display
     */
    public abstract CommandResult undo();
}
```
###### /java/seedu/task/logic/commands/UndoCommand.java
``` java
/**
 * Undoes the most recent modification to the TaskBook
 * @author xuchen
 *
 */
public class UndoCommand extends Command{
	private final Logger logger = LogsCenter.getLogger(UndoCommand.class);
	
	
	public static final String MESSAGE_UNDO_FAILURE = "No more operations to undo";
	public static final String COMMAND_WORD = "undo";
	public static final String MESSAGE_USAGE = COMMAND_WORD +"\n" 
    		+ "Only Undo commands that modify the TaskBook in the same session will be restored.\n "
    		+ "Example: " + COMMAND_WORD;
	
    @Override
	public CommandResult execute() {
		try{
			UndoableCommand toBeUndone = commandList.pop();
			logger.info("-----------[SYSTEM UNDO COMMAND]" + toBeUndone.toString());
			return toBeUndone.undo();
		} catch (UndoableException e) {
			return new CommandResult(MESSAGE_UNDO_FAILURE);
		}

    }
}
```
###### /java/seedu/task/logic/Logic.java
``` java
    /** Convenient method returns all the events */
    List<ReadOnlyEvent> getAllEvents();
    
    /** Convenient method returns all the tasks*/
    List<ReadOnlyTask> getAllTasks();
    
}
```
###### /java/seedu/task/logic/LogicManager.java
``` java
    @Override
    public CommandResult execute(String commandText) {
        logger.info("----------------[USER COMMAND][" + commandText + "]");
        Command command = parser.parseCommand(commandText);
        if(command instanceof UndoableCommand) {
        	UndoableCommand undoableCommand = (UndoableCommand) command;
        	commandList.add(undoableCommand);
        }
        command.setData(model);
        command.setCommandHistory(commandList);
        
        return command.execute();
    }

    @Override
    public ObservableList<ReadOnlyTask> getFilteredTaskList() {
    	model.updateFilteredTaskListToShowWithStatus(Status.INCOMPLETED);
        return model.getFilteredTaskList();
    }

    @Override
    public ObservableList<ReadOnlyEvent> getFilteredEventList() {
    	model.updateFilteredEventListToShowWithStatus(Status.INCOMPLETED);
        return model.getFilteredEventList();
    }
    
    @Override
    public List<ReadOnlyEvent> getAllEvents() {
    	return model.getTaskBook().getEventList();
    }
	
    @Override
	public List<ReadOnlyTask> getAllTasks() {
		return model.getTaskBook().getTaskList();
	}
    
    
}
```
###### /java/seedu/task/logic/parser/ArgumentTokenizer.java
``` java
    /**
     * Returns the preamble regardless of if it is empty. Uses for commands which allow empty preambles. 
     * @return Optional args
     */
    public Optional<String> getPreambleAllowEmpty(){
    	Optional<String> storedPreamble;
    	try{
    		storedPreamble = getValue(new Prefix(""));
    	} catch (EmptyValueException e) {
    		return Optional.empty();
    	}
    	
    	return storedPreamble;
    }

    private void resetTokenizerState() {
        this.tokenizedArguments.clear();
    }

    /**
     * Finds all positions in an arguments string at which any prefix appears
     */
    private List<PrefixPosition> findAllPrefixPositions(String argsString) {
        List<PrefixPosition> positions = new ArrayList<>();

        for (Prefix prefix : this.prefixes) {
            positions.addAll(findPrefixPositions(argsString, prefix));
        }

        return positions;
    }

    /**
     * Finds all positions in an arguments string at which a given {@code prefix} appears
     */
    private List<PrefixPosition> findPrefixPositions(String argsString, Prefix prefix) {
        List<PrefixPosition> positions = new ArrayList<>();

        int argumentStart = argsString.indexOf(prefix.getPrefix());
        while (argumentStart != -1) {
            PrefixPosition extendedPrefix = new PrefixPosition(prefix, argumentStart);
            positions.add(extendedPrefix);
            argumentStart = argsString.indexOf(prefix.getPrefix(), argumentStart + 1);
        }

        return positions;
    }

    /**
     * Extracts the preamble/arguments and stores them in local variables.
     * @param prefixPositions must contain all prefixes in the {@code argsString}
     */
    private void extractArguments(String argsString, List<PrefixPosition> prefixPositions) {

        // Sort by start position
        prefixPositions.sort((prefix1, prefix2) -> prefix1.getStartPosition() - prefix2.getStartPosition());

        // Insert a PrefixPosition to represent the preamble
        PrefixPosition preambleMarker = new PrefixPosition(new Prefix(""), 0);
        prefixPositions.add(0, preambleMarker);

        // Add a dummy PrefixPosition to represent the end of the string
        PrefixPosition endPositionMarker = new PrefixPosition(new Prefix(""), argsString.length());
        prefixPositions.add(endPositionMarker);
        
        // Extract the prefixed arguments and preamble (if any)
        for (int i = 0; i < prefixPositions.size() - 1; i++) {
            String argValue = extractArgumentValue(argsString, prefixPositions.get(i), prefixPositions.get(i + 1));
            saveArgument(prefixPositions.get(i).getPrefix(), argValue);
        }

    }

    /**
     * Returns the trimmed value of the argument specified by {@code currentPrefixPosition}.
     *    The end position of the value is determined by {@code nextPrefixPosition}
     */
    private String extractArgumentValue(String argsString,
                                        PrefixPosition currentPrefixPosition,
                                        PrefixPosition nextPrefixPosition) {
        Prefix prefix = currentPrefixPosition.getPrefix();

        int valueStartPos = currentPrefixPosition.getStartPosition() + prefix.getPrefix().length();
        String value = argsString.substring(valueStartPos, nextPrefixPosition.getStartPosition());

        return value.trim();
    }

    /**
     * Stores the value of the given prefix in the state of this tokenizer
     */
    private void saveArgument(Prefix prefix, String value) {
        if (this.tokenizedArguments.containsKey(prefix)) {
            this.tokenizedArguments.get(prefix).add(value);
            return;
        }

        List<String> values = new ArrayList<>();
        values.add(value);
        this.tokenizedArguments.put(prefix, values);
    }
}
```
###### /java/seedu/task/logic/parser/CalendarParser.java
``` java
/**
 * Parses which parses command argument for show calendar command
 * 
 * @author xuchen
 */
public class CalendarParser implements Parser {

	@Override
	public Command prepare(String args) {
		if (args.isEmpty()) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, CalendarCommand.MESSAGE_USAGE));
		}

		ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(calendarViewDayPrefix);
		argsTokenizer.tokenize(args.trim());
		Optional<String> displayedDateTime = argsTokenizer.getPreambleAllowEmpty();
		boolean toggleToDayView = argsTokenizer.hasPrefix(calendarViewDayPrefix);
		
		CalendarView showView = (toggleToDayView)? CalendarView.DAY : CalendarView.WEEK; 
		
		try {
			return new CalendarCommand(displayedDateTime.orElse(""), showView);
		} catch (IllegalValueException ive) {
			return new IncorrectCommand(ive.getMessage());
		}
	}
}
```
###### /java/seedu/task/logic/parser/FindParser.java
``` java
/**
 * Parser to prepare FindCommand
 * @author xuchen
 *
 */
public class FindParser implements Parser {
	/**
     * Parses arguments in the context of the find person command.
     *
     * @param args full command args string
     * @return the prepared command
     */
	@Override
	public Command prepare(String args) {
		if(args.isEmpty()) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
				FindCommand.MESSAGE_USAGE));
		}
		
		ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(powerSearchPrefix, findKeywordPrefix);
		argsTokenizer.tokenize(args.trim());
		
		Optional<String> keyword = Optional.empty();
		Optional<List<String>> moreKeywords = Optional.empty();
		boolean isPowerSearch = false;
		
		moreKeywords = argsTokenizer.getAllValues(findKeywordPrefix);
		isPowerSearch = argsTokenizer.hasPrefix(powerSearchPrefix);
		keyword = argsTokenizer.getPreambleAllowEmpty();
		
		final Set<String> keywordSet = combineKeywords(keyword, moreKeywords);
		return new FindCommand(keywordSet, isPowerSearch);
	}

	private Set<String> combineKeywords(Optional<String> keyword, Optional<List<String>> moreKeywords) {
		List<String> keywordList = moreKeywords.orElse(new ArrayList<String>());
		
		if(keyword.isPresent()) {
			keywordList.add(keyword.get());
		}
		return new HashSet<>(keywordList);
	}
}
```
###### /java/seedu/task/logic/parser/ListParser.java
``` java
/**
 * Parses list command argument
 * @author xuchen
 *
 */
public class ListParser implements Parser {

	@Override
	public Command prepare(String args) {
		
		ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(taskPresencePrefix, eventPresencePrefix, allPrefix);
		argsTokenizer.tokenize(args.trim());
		boolean showEvent = argsTokenizer.hasPrefix(eventPresencePrefix);
		boolean showTask = argsTokenizer.hasPrefix(taskPresencePrefix);
		boolean showAll = argsTokenizer.hasPrefix(allPrefix);
		Status filter = (showAll) ? Status.ALL : Status.INCOMPLETED;
		
		if(showEvent && !showTask) {
			return new ListCommand(ListTarget.EVENT, filter);
		} else if (showTask && !showEvent) {
			return new ListCommand(ListTarget.TASK, filter);
		} else {
			return new ListCommand(ListTarget.BOTH, filter);
		}
	}
	
	/**
	 * Represents which list to be listed
	 * @author xuchen
	 */
	public enum ListTarget {
		TASK("tasks"), EVENT("events"), BOTH("tasks and events");
		
		private final String value;
		private ListTarget(String value) {
			this.value = value;
		}
		
		@Override
		public String toString() {
			return this.value;
		}
		
	}
}
```
###### /java/seedu/task/logic/UndoableCommandHistory.java
``` java
/**
 * The history for undoable commands. 
 * @author xuchen
 *
 */
public class UndoableCommandHistory {
	
	/** Stack of undoable commands **/
	private Deque<UndoableCommand> commandStack;
	
	public UndoableCommandHistory() {
		this.commandStack = new ArrayDeque<>();
	}
	
	public void add(UndoableCommand command) {
		this.commandStack.addFirst(command);
	}
	
	public UndoableCommand pop() throws UndoableException{
		try{
			return this.commandStack.removeFirst();
		} catch (NoSuchElementException e) {
			throw new UndoableException();
		}
	}	
}
```
###### /java/seedu/task/model/item/Event.java
``` java
    /**
	 * Sort duration from earliest to latest
	 * @param o
	 * @return
	 */
	public int sortAsc(Event o) {
		return this.getDuration().compareTo(o.getDuration());
	}

	public static Comparator<? super Event> getAscComparator() {
		//first by duration
		Comparator<Event> byStartTime = (e1, e2) -> e1.getDuration().compareTo(e2.getDuration());
		
		//then by name
		Comparator<Event> byName = (e1, e2) -> e1.getEvent().compareTo(e2.getEvent());
		
		return byStartTime.thenComparing(byName);
		
	} 
	
}
```
###### /java/seedu/task/model/item/EventDuration.java
``` java
/**
 * Represents an event's duration in the task book. 
 * Guarantees: immutable; 
 * is valid as declared in {@link #isValidDuration(String)}
 */
public class EventDuration implements Comparable<EventDuration> {

	public static final String MESSAGE_DURATION_CONSTRAINTS = "Start time should be no later than end time. \n "
			+ "No abbreviation is allowed for relative, ie: tmrw. \n"
			+ "But Fri, Mon, etc is okay.\n"
			+ "Possible event duration could be:"
			+ "today 4pm /to tomorrow 4pm";
	
	private static final String MESSAGE_DURATION_FORMAT = "%1$s to %2$s";
	private static final long DEFAULT_DURATION = 1;
	
	private LocalDateTime startTime;
	private LocalDateTime endTime;
	

	/**
	 * Creates a given duration.
	 *
	 * @throws IllegalValueException
	 *   		if given duration string is invalid.
	 */
	public EventDuration(String startTimeArg, String endTimeArg) throws IllegalValueException {
		assert startTimeArg != null;
		assert endTimeArg != null;
		try {
			parseDuration(startTimeArg, endTimeArg);
		} catch (IllegalValueException ive) {
			throw new IllegalValueException(MESSAGE_DURATION_CONSTRAINTS);
		}
	}

	
	private void parseDuration(String startTimeArg, String endTimeArg) throws IllegalValueException {
		//if start time empty, set end time first, and start time will be {@code DEFAULT_DURATION} before.  
		if(startTimeArg.isEmpty()) {
			setEndTime(StringUtil.parseStringToTime(endTimeArg));
			setStartTime(getEndTime().minusHours(DEFAULT_DURATION));
			return;
		} 
		
		// if end time empty, set start time first, and end time will be {@code DEFAULT_DURATION} later. 
		if(endTimeArg.isEmpty()) {
			setStartTime(StringUtil.parseStringToTime(startTimeArg));
			setEndTime(getStartTime().plusHours(DEFAULT_DURATION));
			return;
		}
		
		setStartTime(StringUtil.parseStringToTime(startTimeArg));
		setEndTime(StringUtil.parseStringToTime(endTimeArg));
		
		if(!isValidDuration()) {
			throw new IllegalValueException(MESSAGE_DURATION_CONSTRAINTS);
		}
	}

	/**
	 * start time must be before end time.
	 * @return if duration valid
	 */
	private boolean isValidDuration() {
		return getStartTime().isBefore(getEndTime());
	}


	public LocalDateTime getStartTime() {
		return startTime;
	}

	private void setStartTime(LocalDateTime startTime) {
		this.startTime = startTime;
	}

	public LocalDateTime getEndTime() {
		return endTime;
	}

	private void setEndTime(LocalDateTime endTime) {
		this.endTime = endTime;
	}

	@Override
	public String toString() {
		return String.format(MESSAGE_DURATION_FORMAT, 
				getStartTime().format(StringUtil.DATE_FORMATTER), 
				getEndTime().format(StringUtil.DATE_FORMATTER));
	}
	
	/**
	 * format start time for UI 
	 * @return
	 */
	public String getStartTimeAsText() {
		return getStartTime().format(StringUtil.DATE_FORMATTER);
	}
	
	/**
	 * format end time for UI.
	 * @return
	 */
	public String getEndTimeAsText() {
		return getEndTime().format(StringUtil.DATE_FORMATTER);
	}
	
	@Override
	public int compareTo(EventDuration o) {
		if (this.startTime.compareTo(o.startTime) == 0) {
			return this.endTime.compareTo(o.endTime);
		} else {
			return this.startTime.compareTo(o.startTime);
		}
	}
```
###### /java/seedu/task/model/item/Task.java
``` java
	/**
	 * Sort deadline from earliest to latest
	 * @param o
	 * @return
	 */
	public static Comparator<Task> getAscComparator() {
		//first by deadline
		Comparator<Task> byDeadline = (t1, t2) -> {
			if(!t1.getDeadline().isPresent() && !t2.getDeadline().isPresent())
				return 0;
			// if this is a floating task, it will be on the top
			if(!t1.getDeadline().isPresent())
				return 1;
			if(!t2.getDeadline().isPresent()) 
				return -1;
			
			//if both are not floating tasks 
			return t1.getDeadline().get().compareTo(t2.getDeadline().get());
		};
		
		//then by name
		Comparator<Task> byName = (t1, t2) -> t1.getTask().compareTo(t2.getTask());
		
		return byDeadline.thenComparing(byName);
	}
	
	/**
	 * Sort deadline from latest to earliest
	 * @param o
	 * @return
	 */
	public int sortDesc(Task o) {
		if(!this.getDeadline().isPresent() && !o.getDeadline().isPresent())
			return 0;
		// if this is a floating task, it will be on the top
		if(!this.getDeadline().isPresent())
			return 1;
		// if this is 
		if(!o.getDeadline().isPresent()) 
			return -1;
		return this.getDeadline().get().compareTo(o.getDeadline().get())*(-1);
		
	}

}
```
###### /java/seedu/task/model/ModelManager.java
``` java
    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList() {
    	SortedList<Task> sortedTasks = new SortedList<>(filteredTasks);
    	sortedTasks.setComparator(Task.getAscComparator());
    	return new UnmodifiableObservableList<>(sortedTasks);
    }
   
    
    @Override
    public UnmodifiableObservableList<ReadOnlyEvent> getFilteredEventList() {
        SortedList<Event> sortedEvents = new SortedList<>(filteredEvents);
    	sortedEvents.setComparator(Event.getAscComparator());
    	return new UnmodifiableObservableList<>(sortedEvents);
    }

    @Override
    public void updateFilteredTaskListToShowAll() {
        filteredTasks.setPredicate(null);
    }

    @Override
    public void showFoundTaskList(Set<String> keywords, boolean isPowerSearch){
        updateFilteredTaskList(new PredicateExpression(new NameQualifier(keywords, isPowerSearch)));
    }
    
    @Override
    public void showFoundEventList(Set<String> keywords, boolean isPowerSearch){
        updateFilteredEventList(new PredicateExpression(new NameQualifier(keywords, isPowerSearch)));
    }
    
    @Override
	public void updateFilteredTaskListToShowWithStatus(Status status) {
    	if(status == Status.ALL) {
    		updateFilteredTaskListToShowAll();
    	} else {
    		updateFilteredTaskList(new PredicateExpression(new StatusQualifier(status)));
    	}
	}
    
    @Override
	public void updateFilteredEventListToShowWithStatus(Status status) {
    	if(status == Status.ALL) {
    		updateFilteredEventListToShowAll();
    	} else {
    		updateFilteredEventList(new PredicateExpression(new StatusQualifier(status)));
    	}
	}
    
    @Override
	public void updateFilteredEventListToShowAll() {
    	filteredEvents.setPredicate(null);
	}
    
    private void updateFilteredTaskList(Expression expression) {
        filteredTasks.setPredicate(expression::satisfies);
    }
    
    private void updateFilteredEventList(Expression expression) {
        filteredEvents.setPredicate(expression::satisfies);
    }

    //========== Inner classes/interfaces used for filtering ==================================================

    interface Expression {
        boolean satisfies(ReadOnlyTask task);
        boolean satisfies(ReadOnlyEvent event);
        String toString();
    }

    private class PredicateExpression implements Expression {

        private final Qualifier qualifier;

        PredicateExpression(Qualifier qualifier) {
            this.qualifier = qualifier;
        }

        @Override
        public boolean satisfies(ReadOnlyTask task) {
        	qualifier.prepare(task);
            return qualifier.run();
        }

        @Override
		public boolean satisfies(ReadOnlyEvent event) {
        	qualifier.prepare(event);
        	return qualifier.run();
		}
        @Override
        public String toString() {
            return qualifier.toString();
        }
    }

    interface Qualifier {
		boolean run();
		void prepare(ReadOnlyTask task);
		void prepare(ReadOnlyEvent event);
        String toString();
    }

    private class NameQualifier implements Qualifier {
    	private boolean isPowerSearch;
    	private Set<String> keyWords;
    	
        private String targetName;
        private String targetDesc; 
        
        
        NameQualifier(Set<String> keyWords, boolean isPowerSearch) {
            this.keyWords = keyWords;
            this.isPowerSearch = isPowerSearch;
        }

        @Override
        public String toString() {
            return String.join(", ", keyWords);
        }

		@Override
		/**
		 * Filter out those having names and description not matched with the keywords.
		 */
		public boolean run() {
    		List<String> sourceSet = new ArrayList<>();
    		
        	if(isPowerSearch) {
        		//break the name and desc to allow power search
        		sourceSet = new ArrayList<>(Arrays.asList(targetName.split("\\s")));
        		sourceSet.addAll(Arrays.asList(targetDesc.split("\\s")));
        		
        		//break the keyword to allow power search
        		List<String> tempSet = new ArrayList<>(keyWords);
        		keyWords = new HashSet<>();
        		tempSet.stream().forEach(keyword -> keyWords.addAll(Arrays.asList(keyword.split("\\s"))));
        		
        	} else {
        		sourceSet.add(targetName);
        		sourceSet.add(targetDesc);
        	}
        	
        	for(String source: sourceSet) {
    			boolean found = keyWords.stream()
                .filter(keyword -> StringUtil.isSimilar(source.trim(), keyword.trim()))
                .findAny()
                .isPresent();
    			
    			if (found) {
    				return true;
    			}
    		}
    		return false;
		}

		@Override
		public void prepare(ReadOnlyTask task) {
			targetName = task.getTask().fullName;
    		targetDesc = task.getDescriptionValue();
		}

		@Override
		public void prepare(ReadOnlyEvent event) {
			targetName = event.getEvent().fullName;
    		targetDesc = event.getDescriptionValue();
		}
    }
    
    private class StatusQualifier implements Qualifier {
    	private Boolean status;
    	private Boolean targetStatus;
    	
    	StatusQualifier(Status status){
    		switch(status) {
    		case COMPLETED:
    			this.status = true;
    			break;
    		case INCOMPLETED:
    			this.status = false;
    			break;
    		default:
    			this.status = false;
    		}
    	}
    	
		@Override
		public boolean run() {
			return targetStatus.equals(status);
		}
		
		@Override 
		public String toString() {
			return (status ? "completed" : "not yet completed");  
		}

		@Override
		public void prepare(ReadOnlyTask task) {
			targetStatus = task.getTaskStatus();
		}

		@Override
		public void prepare(ReadOnlyEvent event) {
			targetStatus = event.isEventCompleted();
		}
    	
    }

}
```
###### /java/seedu/task/ui/CalendarHelper.java
``` java
public class CalendarHelper extends AppointmentImplBase implements Appointment {
	private static final String EVENT_GROUP = "group11";
	private static final long DEFAULT_DURATION = 1;
	private static final String TASK_GROUP = "group10";
	private static Map<String, AppointmentGroup> groupMap;
	private static CalendarHelper instance;
	
	
	private CalendarHelper() {
		setGroups();
	}
	
	private static void setGroups() {
		groupMap = new HashMap<>();
		for (AppointmentGroup group : new Agenda().appointmentGroups()) {
			groupMap.put(group.getDescription(), group);
		}
	}
	
	public Appointment convertFromEvent(ReadOnlyEvent event) {
		Appointment item = new AppointmentImplLocal();
		item.setSummary(event.getEvent().fullName);
		item.setStartLocalDateTime(event.getDuration().getStartTime());
		item.setEndLocalDateTime(event.getDuration().getEndTime());
		item.setDescription(event.getDescriptionValue());
		item.setAppointmentGroup(groupMap.get(EVENT_GROUP));
		
		return item;
	}
	

	public Appointment convertFromTask(ReadOnlyTask task) {
		Appointment item = new AppointmentImplLocal();
		item.setSummary(task.getTask().fullName);
		item.setStartLocalDateTime(task.getDeadline().get().getTime());
		item.setEndLocalDateTime(item.getStartLocalDateTime().plusHours(DEFAULT_DURATION));
		item.setDescription(task.getDescriptionValue());
		item.setAppointmentGroup(groupMap.get(TASK_GROUP));
		return item;
	}

	public static CalendarHelper getInstance() {
		if (instance == null) {
			instance = new CalendarHelper();
		}
		return instance;
	}

	/**
	 * Compare the equality of a task with an item in the calendar.
	 * @param targetTask
	 * @param taskInCalendar
	 * @return
	 */
	public static boolean compareWithTask(ReadOnlyTask targetTask, Appointment taskInCalendar) {
		assert targetTask.getDeadline().isPresent();
		return taskInCalendar.getSummary().equals(targetTask.getTask().getNameValue())
				&& taskInCalendar.getStartLocalDateTime().equals(targetTask.getDeadline().get().getTime());
	}

	public static boolean compareWithEvent(ReadOnlyEvent targetEvent, Appointment eventInCalendar) {
		return eventInCalendar.getSummary().equals(targetEvent.getEvent().getNameValue())
				&& eventInCalendar.getStartLocalDateTime().equals(targetEvent.getDuration().getStartTime())
				&& eventInCalendar.getEndLocalDateTime().equals(targetEvent.getDuration().getEndTime());
	}
	
	public boolean isTask(Appointment appointment) {
		AppointmentGroup group =  appointment.getAppointmentGroup();
		return group.getStyleClass().equals(TASK_GROUP);
		
	}

	public boolean isEvent(Appointment appointment) {
		return !isTask(appointment);
		
	}
}
```
###### /java/seedu/task/ui/CalendarPanel.java
``` java

/**
 * The Calendar window controller
 * 		Responsible for loading the calendar
 * 		Updating the calendar view 
 * @author xuchen
 *
 */
public class CalendarPanel extends UiPart {
	private static final String CALENDAR_UNSYC_MESSAGE = "Calendar is unsync";
	private static final String CALENDAR_VIEW_ID = "calendar";
	private static final int DEFAULT_BEFORE = -1;
	private static final int DEFAULT_AFTER = 5;
	private static final double DEFAULT_WEEK_VIEW_DAYS= 3.0;
	private Agenda agenda;
	private final Logger logger = LogsCenter.getLogger(CalendarPanel.class);
	private AnchorPane placeHolderPane;
	private final CalendarHelper calHelper;
	
	

	public CalendarPanel() {
		agenda = new Agenda();
		calHelper = CalendarHelper.getInstance();
	}

	public static CalendarPanel load(Stage primaryStage, AnchorPane calendarPlaceHolder,
			List<ReadOnlyEvent> eventList, List<ReadOnlyTask> taskList) {
		CalendarPanel calendarPanel = new CalendarPanel();
		calendarPanel.setupCalendar(primaryStage, calendarPlaceHolder);
		calendarPanel.configure(eventList, taskList);
		return calendarPanel;
	}

	private void setupCalendar(Stage primaryStage, AnchorPane calendarPlaceHolder) {
		logger.info("Setting up Calendar panel...");
		
		setStage(primaryStage);
		setPlaceholder(calendarPlaceHolder);
		setBoundary();
		setWeekView(DEFAULT_BEFORE, DEFAULT_AFTER);
		agenda.setAllowDragging(false);
		agenda.setDisplayedLocalDateTime(LocalDateTime.now());
		resetCallBack();
		addToPlaceHodler();
	}
	
	/**
	 * Set up the week view by setting the default value for the sliders.
	 * @param before
	 * @param after
	 */
	private void setWeekView(int before, int after) {
		AgendaDaysFromDisplayedSkin skin = new AgendaDaysFromDisplayedSkin(this.agenda);
		skin.setDaysBeforeFurthest(before);
		skin.setDaysAfterFurthest(after);
		Slider slider = (Slider)this.agenda.lookup("#daysAfterSlider");
		slider.setValue(DEFAULT_WEEK_VIEW_DAYS);
		this.agenda.setSkin(skin);
	}

	/**
	 * Reset callbacks which modify the calendar so that the calendar depends solely on the event list
	 */
	private void resetCallBack() {
		agenda.setActionCallback( new Callback<Appointment, Void>() {
			@Override
			public Void call(Appointment param) {
				logger.info(param.getSummary() + " is selected. ");
				return null;
			}
		});
		
		agenda.setEditAppointmentCallback( new Callback<Appointment, Void>() {
			@Override
			public Void call(Appointment param) {
				// Do nothing
				return null;
			}
		});
		
		agenda.setNewAppointmentCallback( new Callback<LocalDateTimeRange, Appointment>() {
			@Override
			public Appointment call(LocalDateTimeRange param) {
				// Not allowing adding new events by clicking.
				return null;
			}
		});
		
	}

	private void addToPlaceHodler() {
		SplitPane.setResizableWithParent(placeHolderPane, true);
		agenda.setId(CALENDAR_VIEW_ID);
		placeHolderPane.getChildren().add(agenda);
	}
	

	private void setBoundary() {
		AnchorPane.setTopAnchor(agenda, 0.0);
		AnchorPane.setBottomAnchor(agenda, 0.0);
		AnchorPane.setLeftAnchor(agenda, 0.0);
		AnchorPane.setRightAnchor(agenda, 0.0);
	}

	@Override
	public void setPlaceholder(AnchorPane placeholder) {
		this.placeHolderPane = placeholder;
	}
	
	/**
	 * Set data connection of calendar and the lists
	 * @param eventList
	 * @param taskList
	 */
	private void configure(List<ReadOnlyEvent> eventList, List<ReadOnlyTask> taskList) {
		setConnection(eventList, taskList);
	}
	
	private void setConnection(List<ReadOnlyEvent> eventList, List<ReadOnlyTask> taskList) {
		agenda.appointments().clear();
		agenda.selectedAppointments().clear();
		setConnectionEvent(eventList);
		setConnectionTask(taskList);
	}

	private void setConnectionEvent(List<ReadOnlyEvent> eventList) {
		eventList.forEach(event ->
			agenda.appointments().add(calHelper.convertFromEvent(event)));
	}
	
	private void setConnectionTask(List<ReadOnlyTask> taskList) {
		taskList.stream()
			.filter(task -> task.getDeadline().isPresent() && !task.getTaskStatus().booleanValue())
			.collect(Collectors.toList())
			.forEach(task -> agenda.appointments().add(calHelper.convertFromTask(task)));
	}

	/** 
	 * Refresh data shown when eventlist in model modified
	 * @param eventList
	 */
	public void refresh(List<ReadOnlyEvent> eventList, List<ReadOnlyTask> taskList) {
		logger.info("Refreshing calendar...");
		setConnection(eventList, taskList);
	}

	/**
	 * Toggle the Calendar display mode
	 * @param calendarViewMode
	 */
	public void updateCalendarMode(CalendarView calendarViewMode) {
		switch(calendarViewMode) {
		case DAY:
			agenda.setSkin(new AgendaDaySkin(agenda));
			break;
		case WEEK:
			setWeekView(DEFAULT_BEFORE, DEFAULT_AFTER);
			break;
		default:
			setWeekView(DEFAULT_BEFORE, DEFAULT_AFTER);
		}
	}
	
	/**
	 * Select an event in the calendar and show its details. 
	 * @param targetEvent
	 * @throws exception if calendar is not sync with event list. Restart needed.
	 */
	public void select(ReadOnlyEvent targetEvent) throws CalendarUnsyncException {
		// focus on the event
		LocalDateTime displayedDateTime = targetEvent.getDuration().getStartTime();
		updateCalendarShownPeriod(displayedDateTime);
		
		//highlight the event 
		Appointment targetAppoint  = agenda.appointments()
				.stream()
				.filter((Predicate<? super Agenda.Appointment>) eventInCalendar 
						-> CalendarHelper.compareWithEvent(targetEvent, eventInCalendar))
				.findAny()
				.orElseThrow(()-> new CalendarUnsyncException(CALENDAR_UNSYC_MESSAGE));
		
		agenda.selectedAppointments().add(targetAppoint);
	}

	public void select(ReadOnlyTask targetTask) throws CalendarUnsyncException {
		if(isCompleted(targetTask) || isFloatingTask(targetTask)) {
			return;
		}
		
		LocalDateTime displayedDateTime = targetTask.getDeadline().get().getTime();
		updateCalendarShownPeriod(displayedDateTime);
		
		Appointment targetAppoint = agenda.appointments().stream()
				.filter((Predicate<? super Agenda.Appointment>) taskInCalendar 
						-> CalendarHelper.compareWithTask(targetTask, taskInCalendar))
				.findAny()
				.orElseThrow(() -> new CalendarUnsyncException(CALENDAR_UNSYC_MESSAGE));
		
		agenda.selectedAppointments().add(targetAppoint);
	}
	
	/**
	 * Focus the calendar to a certain time frame
	 * @param t
	 */
	public void updateCalendarShownPeriod(LocalDateTime t) {
		agenda.setDisplayedLocalDateTime(t);
	}
	

	private boolean isFloatingTask(ReadOnlyTask targetTask) {
		return !targetTask.getDeadline().isPresent();
	}

	private boolean isCompleted(ReadOnlyTask targetTask) {
		return targetTask.getTaskStatus();
	}
	
	@Override
	public void setNode(Node node) {

	}

	/**
	 * Not use Fxml
	 * @return
	 */
	@Override
	public String getFxmlPath() {
		return "";

	}
}
```
###### /java/seedu/task/ui/TaskCard.java
``` java
    private boolean isOverdue(ReadOnlyTask task) {
		return task.getDeadline().isPresent() 
				&& task.getDeadline().get().getTime().isBefore(LocalDateTime.now());
	}

	private boolean isDueToday(ReadOnlyTask task) {
		if(task.getTaskStatus() || !task.getDeadline().isPresent()) {
			return false;
		}
		LocalDateTime taskDeadline = task.getDeadline().get().getTime();
		return taskDeadline.getDayOfYear() == LocalDateTime.now().getDayOfYear();
	}

	public HBox getLayout() {
        return cardPane;
    }

    @Override
    public void setNode(Node node) {
        cardPane = (HBox)node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
}
```
###### /java/seedu/task/ui/UiManager.java
``` java
	@Subscribe
	private void handleJumpToEListRequestEvent(JumpToEventListRequestEvent event) {
		logger.info(LogsCenter.getEventHandlingLogMessage(event));
		mainWindow.getEventListPanel().scrollTo(event.targetIndex);
		try {
			mainWindow.getCalendarPanel().select(event.targetEvent);
		} catch (CalendarUnsyncException e) {
			logger.severe(StringUtil.getDetails(e));
			showFatalErrorDialogAndShutdown("Fatal error unsycn calendar:", e);
		}
	}
	
	@Subscribe
	private void handleEventListUpdatedEvent(TaskBookChangedEvent event) {
		logger.info(LogsCenter.getEventHandlingLogMessage(event));
		mainWindow.updateCalendar(event.data.getEventList(), event.data.getTaskList());
	}
	
	@Subscribe 
	private void handleCalendarViewUpdatedEvent(UpdateCalendarEvent event){
		logger.info(LogsCenter.getEventHandlingLogMessage(event));
		mainWindow.updateCalendarView(event.getDisplayedDateTime(), event.getCalendarViewMode());
	}
}
```
###### /resources/view/DarkTheme.css
``` css
@font-face {
	src: url("/roboto/RobotoCondensed-Light.ttf");
}
@font-face {
	src: url("./roboto/Roboto-Bold.ttf");
}
@font-face {
	src: url("./roboto/Roboto-Medium.ttf");
}

.root {
	-fx-font-family: 'Roboto Condensed Light', Arial, sans-serif;
	-fx-focus-color: SaddleBrown;
	-fx-faint-focus-color: SaddleBrown;
}

/* Default for name */
.cell_big_label {
    -fx-font-size: 16px;
    -fx-text-fill: #010504;
}

.cell_desc_label {
    -fx-font-size: 11px !important;
    -fx-text-fill: #2c3e50;
    -fx-background-image: url('/images/desc.png');
    -fx-background-position: left center;
  	-fx-background-repeat: no-repeat;
  	 -fx-background-size: 15px;
}

.cell_ddl_label {
    -fx-font-size: 11px !important;
    -fx-text-fill: #e67e22;
    -fx-background-image: url('/images/calendar.png');
    -fx-background-position: left center;
  	-fx-background-repeat: no-repeat;
  	 -fx-background-size: 15px;
}

.cell_small_label {
    -fx-font-size: 9px;
    -fx-text-fill: #010504;
}

.background {
    -fx-background-color: derive(#1d1d1d, 20%);
}

.label {
    -fx-font-size: 11pt;
   	-fx-font-family: "Roboto Medium", Arial, sans-serif;
    -fx-opacity: 0.9;
}

.label-bright {
    -fx-font-size: 11pt;
    -fx-text-fill: white;
    -fx-opacity: 1;
}

.label-header {
    -fx-font-size: 20pt;
    -fx-font-family: "Roboto Condensed Light", Arial, sans-serif;
    -fx-text-fill: white;
    -fx-opacity: 1;
}

.text-field {
    -fx-font-size: 12pt;
    -fx-font-family: "Roboto Condensed Light", Arial, sans-serif;
}

```
###### /resources/view/Extensions.css
``` css

/**Group 1 for events */
.group11{
	-fx-background-color: #ecf0f1;
	-fx-fill:transparent; 
	-fx-border-width: 4px;
	-fx-text-fill: white;
	-fx-border-width: 5px 0px 5px 0px;
	-fx-border-color: #1abc9c ;
}

/**Group  10 for tasks undone */
.group10 { 
	-fx-background-color:#ecf0f1 ;
	-fx-fill: #AC725E; 
	-fx-border-width: 5px 0px 5px 0px;
	-fx-border-color: #c0392b;
	-fx-text-fill: #7f8c8d;
}

.anchor-pane{
	-fx-background-color: #7f8c8d;
}

.event-panel-header {
	-fx-font-family: 'Roboto Bold', Arial, sans-serif;
	-fx-font-size:20px;
	-fx-text-fill: #ecf0f1;
	-fx-background-color:#c0392b;
}

.task-panel-header {
	-fx-font-size:20px;
	-fx-text-fill: #ecf0f1;
	-fx-background-color:#1abc9c;
	-fx-font-family: 'Roboto Bold', Arial, sans-serif;
}


.Agenda .Selected { 
	-xfx-color: -fx-focused-base;
	-fx-background-color: #f1c40f, -fx-outer-border, -fx-inner-border, #f1c40f;
	-fx-background-insets: -1.4, 0, 1, 2;
	-fx-background-radius: 10, 5, 4, 3;
}

.error {
    -fx-background-color: red;
}

.status-complete {
    -fx-border-color: #2ecc71 !important;
  	-fx-border-width:2px;
    -fx-background-image: url('/images/checked.png');
    -fx-background-position: right center;
  	-fx-background-repeat: no-repeat;
  	-fx-background-size: 25px;
  	-fx-right-padding: 15px;
}


/* For today */
.status-today {
    -fx-background-image: url('/images/notice.png');
    -fx-background-position: right center;
  	-fx-background-repeat: no-repeat;
  	-fx-background-size: 25px;
  	-fx-right-padding: 15px;
}

.status-overdue {
	-fx-background-image: url('/images/overdue.png');
    -fx-background-position: right center;
  	-fx-background-repeat: no-repeat;
  	-fx-background-size: 25px;
  	-fx-right-padding: 10px;
  	-fx-border-color: #c0392b !important;
  	-fx-border-width:2px;
}

.status-overdue .cell_big_label, .status-overdue .cell_index_label {
    -fx-text-fill: #e74c3c;
}


.tag-selector {
    -fx-border-width: 1;
    -fx-border-color: white;
    -fx-border-radius: 3;
    -fx-background-radius: 3;
}

.tooltip-text {
    -fx-text-fill: white;
}



```
